from supporting_files.vectors import Vector
import random
import math
from supporting_files.misc_files import *
from players.direct_sound_w_inheritance import DirectSound
import os
import numpy as np

class Bat:
    _id_counter = 0
    
    def __init__(self, parameters_df):
        self.id = Bat._id_counter
        Bat._id_counter += 1
        
        self.parameters_df= parameters_df
        self.position = Vector(
            random.uniform(1, self.parameters_df["ARENA_WIDTH"][0] - 1),
            random.uniform(1, self.parameters_df["ARENA_HEIGHT"][0] - 1)
        )
        self.direction = Vector().random_direction() #randomize start direction
        self.speed = self.parameters_df['BAT_SPEED'][0]
        self.time_since_last_call = random.uniform(0, 1/self.parameters_df['CALL_RATE'][0])
        self.emitted_sounds = []  # Only stores DirectSound objects that was generated by it
        self.received_sounds = [] # Stores all received sounds; EchoSound of its own calls plus DirectSound + EchoSound of other bats
        self.position_history = [] # Stirees all the position information 
        self.time_since_last_cleanup = 0 # Clean up activates after every some steps to clear memory from RAM and store it on drive
    
    # TODO: dont allow movement through obstacles/ other bats
    def update(self, time_elapsed, obstacles, bats, current_time, sound_objects):
        self._update_movement(time_elapsed)
        self.position_history.append((current_time, (self.position.x, self.position.y)))
        
        self._emit_sounds(time_elapsed, current_time, sound_objects)
        self._detect_sounds(current_time, sound_objects)
        self._cleanup_sounds(current_time)
    
    def _update_movement(self, time_elapsed):
        self.position += self.direction * self.speed * time_elapsed
        
        # Boundary checks with bounce
        if self.position.x <= 0 or self.position.x >= self.parameters_df["ARENA_WIDTH"][0]:
            self.direction.x *= -1
        if self.position.y <= 0 or self.position.y >= self.parameters_df["ARENA_HEIGHT"][0]:
            self.direction.y *= -1
            
        # Random direction change occasionally
        if random.random() < self.parameters_df['PROPENSITY_TO_CHANGE_DIRECTION'][0]:
            self.direction = Vector().random_direction()
    
    def _emit_sounds(self, time_elapsed, current_time, sound_objects):
        self.time_since_last_call += time_elapsed
        call_interval = 1.0 / self.parameters_df['CALL_RATE'][0]
        
        if self.time_since_last_call >= call_interval:
            sound = DirectSound(
                parameters_df=self.parameters_df,
                origin=self.position,
                creation_time=current_time,
                emitter_id=self.id
            )
            self.emitted_sounds.append(sound)
            sound_objects.append(sound)
            self.time_since_last_call = 0
    
    def _detect_sounds(self, current_time, sound_objects):
        for sound in sound_objects:
            if not sound.active:
                continue
                
            sound.update(current_time)

            if sound.current_spl< self.parameters_df['MIN_DETECTABLE_SPL'][0]:
                continue

            if sound.contains_point(self.position):
                sound_type = 'direct' if isinstance(sound, DirectSound) else 'echo'
                self.received_sounds.append({
                    'time': current_time,
                    'position': (sound.origin.x, sound.origin.y),
                    'distance': sound.origin.distance_to(self.position),
                    'spl': sound.current_spl,
                    'emitter_id': sound.emitter_id,
                    'type': sound_type,
                    'reflection_count': getattr(sound, 'reflection_count', 0),
                    'parent_id': getattr(sound, 'parent_id', None)
                })
    
    def _cleanup_sounds(self, current_time):
        # Keep only recent detections
        if (current_time-self.time_since_last_cleanup)>0.1: #10ms
            dir_to_store= 'simulation_results/'+str(self.id)
            make_dir(dir_to_store)
            np.save(dir_to_store+f'/received_sounds_snapshot_at_time_{current_time}.npy', self.received_sounds)
            np.save(dir_to_store+f'/emitted_sounds_snapshot_at_time_{current_time}.npy', self.emitted_sounds)
            self.time_since_last_cleanup= current_time
            self.emitted_sounds = []
            self.received_sounds = []
    
    def get_detections_at_time(self, current_time):
        return [d for d in self.received_sounds if d['time'] <= current_time]
    
    def __repr__(self):
        return f"Bat(id={self.id}, position={self.position})"