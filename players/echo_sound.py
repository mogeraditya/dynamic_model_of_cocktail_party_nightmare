from supporting_files.vectors import Vector
import math

# TODO: EchoSound is inherited from DirectSound

class EchoSound:
    def __init__(self, parameters_df, origin, creation_time, emitter_id, initial_spl, parent_creation_time, reflection_count):
        self.parameters_df= parameters_df
        self.origin = origin
        self.creation_time = creation_time
        self.emitter_id = emitter_id
        self.initial_spl = initial_spl
        self.current_spl = initial_spl
        self.parent_creation_time = parent_creation_time  # ID of sound that created this echo
        self.reflection_count = reflection_count
        self.current_radius = 0
        self.max_radius = self.parameters_df['SOUND_SPEED'][0] * self.parameters_df['CALL_DURATION'][0]
        self.active = True # Keep track of when to kill sound; either when db is below 20 or when out of arena
        self.has_reflected = False  # Keep track of if it has reflected in the past
        self.reflected_obstacles = set() # Keep track on number of echoes generated by self
        
    def update(self, current_time):
        elapsed = current_time - self.creation_time
        self.current_radius = self.parameters_df['SOUND_SPEED'][0] * elapsed
        
        # Calculate spl with distance and air absorption
        if self.current_radius > 0:
            distance_effect = 20 * math.log10(self.current_radius/0.1)
            self.current_spl = (self.initial_spl - distance_effect - 
                              (self.parameters_df['AIR_ABSORPTION'][0] * self.current_radius))
        
        # if current_time >= self.creation_time + Constants.CALL_DURATION:
        #     self.active = False
        if self.check_if_sound_outside_arena_simpler():
            self.active = False
    
    def contains_point(self, point):
        """Check if point is within the sound disk"""
        distance = self.origin.distance_to(point)
        return distance <= self.current_radius and distance >= max(0, self.current_radius - self.parameters_df['SOUND_DISK_WIDTH'][0])
    
    def create_echo(self, point, current_time, normal):
        if (self.has_reflected or 
            self.reflection_count >= self.parameters_df['MAX_REFLECTIONS'][0]):
            return None
            
        reflected_spl = self.current_spl - self.parameters_df['REFLECTION_LOSS'][0]
        if reflected_spl < self.parameters_df['MIN_DETECTABLE_SPL'][0]:
            return None
        
        self.has_reflected = True
        echo = EchoSound(
            parameters_df=self.parameters_df,
            origin=point,
            creation_time=current_time,
            emitter_id=self.emitter_id,
            initial_spl=reflected_spl,
            parent_creation_time=id(self),
            reflection_count=self.reflection_count + 1
        )
        echo.reflected_obstacles.update(self.reflected_obstacles)
        return echo
    
    def __repr__(self):
        return (f"EchoSound(origin={self.origin}, radius={self.current_radius:.2f}, "
                f"spl={self.current_spl:.1f}dB, reflections={self.reflection_count}, "
                f"emitter={self.emitter_id}, parent={self.parent_creation_time})")
    
    def check_if_sound_outside_arena_simpler(self):
        if (self.current_radius)>max(self.parameters_df["ARENA_HEIGHT"][0], self.parameters_df["ARENA_WIDTH"][0]):

            return True
        else:
            return False