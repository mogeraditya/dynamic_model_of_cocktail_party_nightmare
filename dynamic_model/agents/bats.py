"""This module contains the code that describes a Bat object and its behaviours"""

import random

import numpy as np
from agents.sounds import DirectSound
from supporting_files.utilities import make_dir
from supporting_files.vectors import Vector


class Bat:
    _id_counter = 0

    def __init__(self, parameters_df, output_dir):
        self.id = Bat._id_counter
        Bat._id_counter += 1

        self.parameters_df = parameters_df
        self.position = Vector(
            random.uniform(1, self.parameters_df["ARENA_WIDTH"][0] - 1),
            random.uniform(1, self.parameters_df["ARENA_HEIGHT"][0] - 1),
        )
        self.direction = Vector().random_direction()  # randomize start direction
        self.time_since_last_call = random.uniform(
            0, 1 / self.parameters_df["CALL_RATE"][0]
        )
        # Only stores DirectSound objects that was generated by it.
        self.emitted_sounds = []
        # Stores all received sounds;
        # EchoSound of its own calls plus DirectSound + EchoSound of other bats.
        self.received_sounds = []
        # Stores all the position information.
        self.position_history = []
        # Clean up activates after every some steps to clear memory from RAM and store it on drive.
        self.time_since_last_cleanup = self.time_since_last_call
        self.output_dir = output_dir
        self.speed = self.parameters_df["BAT_SPEED"][0]
        self.radius = self.parameters_df["BAT_RADIUS"][0]

    # TODO: dont allow movement through obstacles/ other bats
    def update(self, current_time, sound_objects):
        """Function to update bats with time.
        This function handles movement update of bat each time step.
        Also takes care of sound emission, detection of active sounds by the bats.
        Bat detections over time is also cleared and stored locally.

        Args:
            current_time (float): Time, in seconds, for which the simualtion has been running.
            sound_objects (EchoSound): direct and echo sounds that are currently active.
        """

        self.update_movement()
        self.position_history.append((current_time, (self.position.x, self.position.y)))

        self.time_since_last_call += self.parameters_df["TIME_STEP"][0]
        call_interval = 1.0 / self.parameters_df["CALL_RATE"][0]
        if self.time_since_last_call >= call_interval:
            self.emit_sounds(current_time, sound_objects)
            self.detect_sounds(current_time, sound_objects)
            self.time_since_last_call = 0

        self.decide_next_direction(self.received_sounds)
        self.cleanup_sounds(current_time)

    def update_movement(self):
        """Update poisition of Bat when called.
        Every timestep the position of the bat needs to be
        updated based on velcoity and direction.
        """
        self.position += (
            self.direction * self.speed * self.parameters_df["TIME_STEP"][0]
        )

        # Boundary checks with bounce
        if (
            self.position.x <= 0
            or self.position.x >= self.parameters_df["ARENA_WIDTH"][0]
        ):
            self.direction.x *= -1
        if (
            self.position.y <= 0
            or self.position.y >= self.parameters_df["ARENA_HEIGHT"][0]
        ):
            self.direction.y *= -1

    def emit_sounds(self, current_time, sound_objects):
        """Trigger sound emission by Bat.
        Whenever the function is called, it checks if sufficient time
        has passed and a DirectSoundObject is created.

        Args:
            current_time (float): Time, in seconds, for which the simualtion has been running.
            sound_objects (list): List containing all active sounds in the simulation
        """
        # self.time_since_last_call += self.parameters_df["TIME_STEP"][0]
        # call_interval = 1.0 / self.parameters_df["CALL_RATE"][0]

        # if self.time_since_last_call >= call_interval:
        sound = DirectSound(
            parameters_df=self.parameters_df,
            origin=self.position,
            creation_time=current_time,
            emitter_id=self.id,
        )
        self.emitted_sounds.append(sound)
        sound_objects.append(sound)

    def detect_sounds(self, current_time, sound_objects):
        """Detects sound that are audible to the Bat
        Checks if a bat can hear a sound based on dbSpl of sound
        and position of bat.

        Args:
            current_time (float): Time, in seconds, for which the simualtion has been running.
            sound_objects (list): _description_
        """
        for sound in sound_objects:
            if not sound.active:
                continue

            if sound.emitter_id == self.id and isinstance(sound, DirectSound):
                continue
            # sound.update(current_time)

            if sound.current_spl < self.parameters_df["MIN_DETECTABLE_SPL"][0]:
                continue

            if sound.contains_point(self.position):
                sound_type = "direct" if isinstance(sound, DirectSound) else "echo"
                self.received_sounds.append(
                    {
                        "time": current_time,
                        "position": (sound.origin.x, sound.origin.y),
                        "distance": sound.origin.distance_to(self.position),
                        "spl": sound.current_spl,
                        "emitter_id": sound.emitter_id,
                        "type": sound_type,
                        "reflection_count": getattr(sound, "reflection_count", 0),
                        # 'parent_id': getattr(sound, 'parent_id', None),
                        "reflected_from": sound.reflected_from,
                        "sound_object_id": id(sound),
                    }
                )

    def cleanup_sounds(self, current_time):
        """Stores the detections into a .npy file.
        After a fixed amount of time the detection list is stored
        into local memory and this is cleared from RAM.

        Args:
            current_time (float): Time, in seconds, for which the simualtion has been running.
        """
        # Keep only recent detections
        if (current_time - self.time_since_last_cleanup) >= self.parameters_df[
            "CLEANUP_INTERVAL"
        ][0] or np.round(
            self.time_since_last_cleanup, 3
        ) == current_time:  # 10ms
            dir_to_store = self.output_dir + "/" + str(self.id)
            make_dir(dir_to_store)
            np.save(
                dir_to_store
                + f"/bat_{self.id}_received_sounds_snapshot_at_time_{current_time:.3f}.npy",
                self.received_sounds,
            )
            np.save(
                dir_to_store
                + f"/bat_{self.id}_emitted_sounds_snapshot_at_time_{current_time:.3f}.npy",
                self.emitted_sounds,
            )
            self.time_since_last_cleanup = current_time
            self.emitted_sounds = []
            self.received_sounds = []

    def get_detections_at_time(self, current_time):
        """

        Args:
            current_time (float): Time, in seconds, for which the simualtion has been running.

        Returns:
            list: sounds that are detected by a bat before a certain time.
        """
        return [d for d in self.received_sounds if d["time"] <= current_time]

    # inelligent movement
    def generate_random_direction(self):
        """assign a random direction to the bat"""
        if random.random() < self.parameters_df["PROPENSITY_TO_CHANGE_DIRECTION"][0]:
            self.direction = Vector().random_direction()

    def generate_direction_vector_given_sound(self, sound):
        """generate direction vector of any sound

        Args:
            sound (EchoSound): sound to convert to vector

        Returns:
            Vector: Vector form of the input sound
        """
        spl_of_sound = sound["spl"]

        normalized_sound_vector = (
            Vector(x=sound["position"][0], y=sound["position"][1]) - self.position
        ).normalize()

        vector_w_spl_magnitude = normalized_sound_vector * spl_of_sound
        return vector_w_spl_magnitude

    def decide_next_direction(self, detected_sound_objects):
        """decide next direction of bat based on sound

        Args:
            detected_sound_objects (list): list containing detected sounds
        """

        if len(detected_sound_objects) != 0:
            max_spl = np.max([i["spl"] for i in detected_sound_objects])
            if max_spl > 20:

                max_spl_sound = [
                    i for i in detected_sound_objects if i["spl"] == max_spl
                ][0]
                # sum_of_sound_vectors = Vector(0, 0)
                # for sound in detected_sound_objects:
                #     sum_of_sound_vectors += (
                #         self.generate_direction_vector_given_sound(sound)
                #     )
                # mean_vector = sum_of_sound_vectors * (
                #     1 / len(detected_sound_objects)
                # )
                max_spl_sound_vector = self.generate_direction_vector_given_sound(
                    max_spl_sound
                )
                if max_spl > 82:
                    print("repulse")
                    next_direction = max_spl_sound_vector.rotate(np.pi)
                    # next_direction = mean_vector.rotate(np.pi)
                    self.direction = next_direction.normalize()
                else:
                    print("attract")
                    next_direction = max_spl_sound_vector
                    # next_direction = mean_vector
                    self.direction = next_direction.normalize()

            else:
                # Random direction change occasionally
                self.generate_random_direction()
        else:
            self.generate_random_direction()
            print("random")

    def __repr__(self):
        return f"Bat(id={self.id}, position={self.position})"
