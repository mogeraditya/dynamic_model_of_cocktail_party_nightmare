import random

import numpy as np
from agents.sounds import DirectSound
from supporting_files.utilities import *
from supporting_files.vectors import Vector


class Bat:
    _id_counter = 0

    def __init__(self, parameters_df, output_dir):
        self.id = Bat._id_counter
        Bat._id_counter += 1

        self.parameters_df = parameters_df
        self.position = Vector(
            random.uniform(1, self.parameters_df["ARENA_WIDTH"][0] - 1),
            random.uniform(1, self.parameters_df["ARENA_HEIGHT"][0] - 1),
        )
        self.direction = Vector().random_direction()  # randomize start direction
        self.speed = self.parameters_df["BAT_SPEED"][0]
        self.time_since_last_call = random.uniform(
            0, 1 / self.parameters_df["CALL_RATE"][0]
        )
        # Only stores DirectSound objects that was generated by it.
        self.emitted_sounds = []
        # Stores all received sounds;
        # EchoSound of its own calls plus DirectSound + EchoSound of other bats.
        self.received_sounds = []
        # Stores all the position information.
        self.position_history = []
        # Clean up activates after every some steps to clear memory from RAM and store it on drive.
        self.time_since_last_cleanup = self.time_since_last_call
        self.output_dir = output_dir
        self.time_step = parameters_df["TIME_STEP"][0]

    # TODO: dont allow movement through obstacles/ other bats
    def update(self, current_time, sound_objects):
        """Function to update bats with time.
        This function handles movement update of bat each time step.
        Also takes care of sound emission, detection of active sounds by the bats.
        Bat detections over time is also cleared and stored locally.

        Args:
            self.time_step (float): _description_
            obstacles (Obstacle): _description_
            bats (Bat): _description_
            current_time (float): _description_
            sound_objects (EchoSound): _description_
        """

        self.update_movement()
        self.position_history.append((current_time, (self.position.x, self.position.y)))

        self.emit_sounds(current_time, sound_objects)
        self.detect_sounds(current_time, sound_objects)
        self.cleanup_sounds(current_time)

    def update_movement(self):
        self.position += self.direction * self.speed * self.time_step

        # Boundary checks with bounce
        if (
            self.position.x <= 0
            or self.position.x >= self.parameters_df["ARENA_WIDTH"][0]
        ):
            self.direction.x *= -1
        if (
            self.position.y <= 0
            or self.position.y >= self.parameters_df["ARENA_HEIGHT"][0]
        ):
            self.direction.y *= -1

        # Random direction change occasionally
        if random.random() < self.parameters_df["PROPENSITY_TO_CHANGE_DIRECTION"][0]:
            self.direction = Vector().random_direction()

    def emit_sounds(self, current_time, sound_objects):
        self.time_since_last_call += self.time_step
        call_interval = 1.0 / self.parameters_df["CALL_RATE"][0]

        if self.time_since_last_call >= call_interval:
            sound = DirectSound(
                parameters_df=self.parameters_df,
                origin=self.position,
                creation_time=current_time,
                emitter_id=self.id,
            )
            self.emitted_sounds.append(sound)
            sound_objects.append(sound)
            self.time_since_last_call = 0

    def detect_sounds(self, current_time, sound_objects):
        for sound in sound_objects:
            if not sound.active:
                continue

            sound.update(current_time)

            if sound.current_spl < self.parameters_df["MIN_DETECTABLE_SPL"][0]:
                continue

            if sound.contains_point(self.position):
                sound_type = "direct" if isinstance(sound, DirectSound) else "echo"
                self.received_sounds.append(
                    {
                        "time": current_time,
                        "position": (sound.origin.x, sound.origin.y),
                        "distance": sound.origin.distance_to(self.position),
                        "spl": sound.current_spl,
                        "emitter_id": sound.emitter_id,
                        "type": sound_type,
                        "reflection_count": getattr(sound, "reflection_count", 0),
                        # 'parent_id': getattr(sound, 'parent_id', None),
                        "reflected_from": sound.reflected_from,
                        "sound_object_id": id(sound),
                    }
                )

    def cleanup_sounds(self, current_time):
        # Keep only recent detections
        if (current_time - self.time_since_last_cleanup) >= self.parameters_df[
            "CLEANUP_INTERVAL"
        ][
            0
        ]:  # 10ms
            dir_to_store = self.output_dir + "/" + str(self.id)
            make_dir(dir_to_store)
            np.save(
                dir_to_store
                + f'/bat_{self.id}_received_sounds_snapshot_at_time_{"%.3f" % current_time}.npy',
                self.received_sounds,
            )
            np.save(
                dir_to_store
                + f'/emitted_sounds_snapshot_at_time_{"%.3f" % current_time}.npy',
                self.emitted_sounds,
            )
            self.time_since_last_cleanup = current_time
            self.emitted_sounds = []
            self.received_sounds = []

    def get_detections_at_time(self, current_time):
        return [d for d in self.received_sounds if d["time"] <= current_time]

    def __repr__(self):
        return f"Bat(id={self.id}, position={self.position})"
